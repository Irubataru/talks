---
title: The Rust programming language
date: 2023-08-29
author: Aleksandra
styles:
  slides:
    fg: "#c0caf5" 
    bg: "#24283b"
  code:
    style: one-dark
    inline_lang: rust
    bg_override: "#24283b"
  margin:
    top: 3
    bottom: 1
  padding:
    top: 3
    bottom: 3
---

# What is Rust?

- Compiled language
- Type safe
- Memory safe

# Syntax

```rust
#[derive(Clone, Debug)]
pub struct Graph {
    pub nodes: Vec<Node>,
    pub edges: Vec<Edge>,
}

impl Graph {
    pub fn is_preferred(&self, e1: &Edge, e2: &Edge) -> bool {
        if e1.cost < e2.cost {
            return true;
        }

        if e2.cost < e1.cost {
            return false;
        }

        self.edges.iter().position(|e| e == e1).expect("Edge 1 not in graph")
            < self.edges.iter().position(|e| e == e2).expect("Edge 2 not in graph")
    }

    pub fn adjacent_edges<'a>(&'a self, node: &'a Node) -> impl Iterator<Item = &'a Edge> {
        self.edges.iter().filter(|&e| e.has_node(*node))
    }
}
```

# Move by default

In Rust, assignments are move by default

- In C++ we have copy by default
- In C# we have reference by default

<!-- stop -->

```rust
let a = String::new();   // ← a owns created resource 
let b = a;               // ← b now owns this resource
println!("{}", &a)       // ← compile error! borrow after move
```

<!-- stop -->
<br/>Compiling `move.rs`

```
error[E0382]: borrow of moved value: `a`
 --> move.rs:4:20
  |
2 |     let a = String::new();
  |         - move occurs because `a` has type `String`,
  |           which does not implement the `Copy` trait
4 |     let b = a;
  |             - value moved here
5 |     println!("{}", a);
  |                    ^ value borrowed here after move
```

# Mutating variables

Variables in rust are immutable (cost) by default

```rust
let str = String::new();
str.push_str("Hello world");
println!("{}", &str);
```

<!-- stop -->

<br/><br/>Compiling `mutate.rs`

```
error[E0596]: cannot borrow `str` as mutable, as it is not declared as mutable
 --> mutate.rs:3:4
  |
2 |    let str = String::new();
  |        --- help: consider changing this to be mutable: `mut str`
3 |    str.push_str("Hello world");
  |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable
```

# Mutating variables

Variables in rust are immutable (const) by default

```rust
let mut str = String::new();
str.push_str("Hello world");
println!("{}", &str);  // Prints "Hello world"
```

<br/><br/>To mutate them they need to be marked so using the `mut` keyword.

# Borrowing

Taking a reference is called *borrowing*

You cannot mutate a borrowed variable

```rust
let mut a = String::from("Hello");
let b = &a;
a.push_str(" Optimisation!");
println!("{}", b); // Without this it compiles because it checks for future uses
```

<!-- stop -->

<br/>Compiling `mutate_borrow.rs`

```
error[E0502]: cannot borrow `a` as mutable because it is also borrowed as immutable
 --> mutate_borrow.rs:4:5
  |
3 |     let b = &a;
  |             -- immutable borrow occurs here
4 |     a.push_str(" Optimisation!");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
5 |     println!("{}", b);
  |                    - immutable borrow later used here
```

# Borrowing

Taking a reference is called *borrowing*

You cannot mutate a borrowed variable

```rust
let mut a = String::from("Hello");
let b = &mut a;
a.push_str(" Optimisation!");
println!("{}", b); // Without this it compiles because it checks for future uses
```

<br/>You also cannot borrow a variable as mutable more than once

```
error[E0499]: cannot borrow `a` as mutable more than once at a time
 --> mutate_borrow.rs:4:5
  |
3 |     let b = &mut a;
  |             ------ first mutable borrow occurs here
4 |     a.push_str(" Optimisation!");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here
5 |     println!("{}", b);
  |                    - first borrow later used here
```

# Enums

Rust has _proper_ enums, i.e. they are not just a set of numbers.

Rust enums can also wrap data.

```rust
enum Things {
   City(String),
   Prime(u32),
   Colour(u8, u8, u8),
   Dog { name: String, species: DogSpecies }
}

enum DogSpecies {
   Dachs,
   GoldenRetriever,
   ...
}
```

The size of the enum object will then be the size of the option with the largest
sized data.

# Matching on enums

```rust
enum Thing {
   City(String),
   Prime(u32),
   Colour(u8, u8, u8),
   Dog { name: String, species: DogSpecies }
}

fn pretty_print_thing(thing: &Thing) {
    match thing {
        Thing::City(city_name) => println!("You are in {}", city_name),
        Thing::Prime(number) => println!("The prime number is {}", number),
        Thing::Colour(red, green, blue) => println!("Hex code for colour is {:02x}{:02x}{:02x}", red, green, blue),
        Thing::Dog { name, species } => println!("{} is a good dog! A perfect {:?}", name, species)
    }
}

fn get_dog_species(thing: &Thing) -> Option<DogSpecies> {

   if let Thing::Dog { name: _, species} = thing {
       return Some(*species);
   }

   None   // No need for return statement on last line
}
```

# `Option<T>` as "nullable"

Nullable in Rust is implemented as the `Option<T>` enum

```rust
enum Option<T> {
   Some(T),
   None
}
```

For instance a `Vec<T>` has a method `first()` 

```rust
impl<T> Vec<T> {
   fn first(&self) -> Option<&T> {
       if self.is_empty() {
           return None; 
       }

       Some(self[0])
   } 
}
```

To use these values you need to _match_ on them like other enums.

<!-- stop -->
There is also some helper syntax for transient calls using `?`

```rust
fn add_one_to_opt(value: Option<u8>) -> Option<u8> {
    Some(value? + 1)
}
```

# Exceptions with `Result<T,E>`

Exceptions in Rust are implemented as the `Result<T,E>` enum

```rust
enum Resut<T,E> {
   Ok(T),
   Err(E)
}
```

There is no throwing and propagation up the call stack, the errors must always
be handled.

<!-- stop -->
<br/>In addition to matching them as enums they also have helpers to unwrap the
result

```rust
let value = Ok(42);
value.unwrap();                   // panics if value is Err
value.unwrap_or(12);              // returns 12 is value is Err
value.expect("Expect no errors"); // Unwrap with custom error message
```

<!-- stop -->
<br/>There is also some helper syntax for transient calls using `?`

```rust
fn main() -> Result<(), Box<dyn Error>> {
    let file = File::open("file")?;

    Ok(())
}
```

# Traits

Traits are the closet we come to interfaces in Rust, but they are more akin to
concepts in C++

# Templates

```rust
trait Describable {
   fn describe(&self) -> String;
}
```

# Iterators and lambdas

# Box, Rc ?

# Cargo
